MULTITHREADING

1. What is multithreading?
Multithreading allows us to execution of mutliple threads simultaneusly , thread is the smallest unit of the process which can get executed independently , multithreading helps us to improve the performance of the application.
2. We can achive mutiplethreading in java by 2 ways :
 by extending Thread class and override its run () method 
 ex: 
 class MyThread extends Thread {
	public void run() { }
		MyThread my = new MyThread();
		my.start();
		}
 by implementing Runnable interface override its run method ,passed its instance as thread constructor.
 ex:
 class MyRunnable implements Runnable {
	public void run () {}
	MyRunnable my = new MyRunnable();
	Thread thread = new Thread(my);
	thread.start();
	
3. Why Multithreading?
Interviewers expect you to say:

1. Better CPU Utilization

Threads run in parallel, keeping CPU busy.

2. Faster Execution

Multiple tasks run simultaneously.

3. Improved Application Performance

Background tasks (logging, file upload, audit queue processing, etc.) run without blocking main logic.

4. Used in Real Projects

Producerâ€“Consumer

WebServer handling multiple requests

Async tasks (email/SMS sending)

Thread pool executor in Spring

ðŸŸ¦ Step 1: What is a Thread? (Basic Foundation)
ðŸ‘‰ Simple definition:

A thread is like a small worker inside your program that performs a task.

ðŸ’¡ Real-Life Example:

Imagine you have a kitchen with:

1 cook â†’ single-thread

3 cooks â†’ multi-thread

More cooks = more work done in parallel.

ðŸ§  In Java:

A Java program normally has multiple threads:

Main thread â€“ runs your main method

GC thread â€“ runs garbage collector

User defined threads â€“ you create them

ðŸŸ¦ Step 2: Why do we need Threads?
Without threads:

Your program works one task at a time.

With threads:

Your program can do multiple tasks at the same time.

Real Example:

A web server:

Thread1 â†’ login request

Thread2 â†’ payment request

Thread3 â†’ fetch profile

Thread4 â†’ send OTP

So each request gets its own thread.

ðŸŸ¦ Step 3: How to create a Thread? (Very Easy)

There are 2 ways.

Way 1 â†’ Extending Thread class
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // starts new thread
    }
}

ðŸ”¥ Important:

start() â†’ starts a new thread

run() â†’ contains the code to execute

Never call run() manually

Way 2 â†’ Implementing Runnable (Best method)
class MyTask implements Runnable {
    public void run() {
        System.out.println("Task running...");
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t = new Thread(new MyTask());
        t.start();
    }
}

Why Runnable is better?

Because Java doesnâ€™t allow multiple inheritance.
You can extend one class only, so using Runnable is flexible.

ðŸŸ© Step 4: Thread Lifecycle (Very Important)

Threads go through different states:

NEW â†’ RUNNABLE â†’ RUNNING â†’ WAITING/BLOCKED â†’ TERMINATED

Simple explanation:

NEW: thread object created

RUNNABLE: start() is called but waiting for CPU

RUNNING: using CPU

WAITING: sleeping/waiting for lock

TERMINATED: done

ðŸŸ¦ Step 5: Thread Methods (Very Simple Today)
Method	What it does
start()	start new thread
run()	thread logic/task
sleep(1000)	pauses thread
join()	wait for other thread
yield()	give chance to others
interrupt()	interrupt sleeping thread
ðŸŸ§ Step 6: Understanding Race Condition (Very Important)
What is race condition?

When two or more threads try to modify the same data at same time, data becomes inconsistent.

Example:

Two threads increasing balance:

Thread1: balance = balance + 100
Thread2: balance = balance + 100


Result might be:

200

OR 100

OR wrong value

This is where synchronization comes.

ðŸŸ¥ Step 7: Synchronization (Beginner Level Today)
Definition:

Synchronization means only one thread can access code at a time.

synchronized void increment() {
    count++;
}


This prevents data corruption.

ðŸŸ¦ Todayâ€™s Summary (You learned):

âœ” What is a thread
âœ” Why use threads
âœ” How to create threads
âœ” What is run() & start()
âœ” Thread lifecycle
âœ” Race condition
âœ” Basic synchronization

ðŸ”¥ STEP 2 â€” Advanced Multithreading Concepts

1. Synchronized block vs Synchronized method:

Synchronized method :
~Lock is on entire method.
~Slower -> becuase whole method is locked.

ex: 
synchronized void increment() {
count++;
}

Synchronized block:
~ Lock is on specific part of method.
~ Faster -> coz only specific part is locked.

void increment() {
	synchronized(this) {
		count++;
		}
	}

We use synchronized blocks to improve the app performance by locking only required code instead of locking entire method.

realtime project : used in authenticationService , schedulersClasses for run schedulers jobs.

2. What is Volatile keyword?
Problem: 
If two threads accessing the variables , one thread may not see updated immediately because threads store variables in CPU cache.
Solution:
	volatile boolean flag = true;
Meaning:
variable value is always read from main memory.
all threads get updated value immediately

3. Deadlock 
Deadlock is the situation where every thread is in waiting state for the resource availability and the thread which currently occupied the resource that is also into the waiting state such situation is called as Deadlock.

Real Life Example:
Boyfriend has phone and wants charger.
Girlfriend has charger and wants phone.
Both are waiting â†’ no one gives â†’ deadlock.

4.Runnable VS Callable Interfaces

| Runnable               | Callable               |
| ---------------------- | ---------------------- |
| override run()         | override call()        |
| no return value        | returns value          |
| cannot throw exception | can throw exception    |
| used for simple tasks  | used for complex tasks |

5. Thread Pools (Executor Framework)

Creating too many threads â†’ memory issue.

So Java introduced Thread Pool.

ex:
ExecutorService executor = Executors.newFixedThreadPool(5);

executor.submit(() -> {
    System.out.println("Task executed");
});

Benefits:
Reuses threads
Faster
Controlled number of threads
Best for production systems

Important thread pools:
| Pool                    | Use               |
| ----------------------- | ----------------- |
| newFixedThreadPool      | fixed threads     |
| newCachedThreadPool     | unlimited threads |
| newSingleThreadExecutor | only 1 thread     |
| newScheduledThreadPool  | delayed tasks     |
