Java Core -

1. what is difference between JDK & JRE?
-> JDK - java development Kit which is a software development environment for building Java apps. Write & compile code. ex: javac MyApp.java (javac comes from JDK)
JRE - JAVA Runtime Environment , which is required to run Java programs.Run the code. ex; java MyApp (java command & JVM comes from JRE).

2. Why is Java Platform independent language?
-> Java is the Platform independent coz of the concept of JVM and byteCode.
-> Java is platform independent becuase the compiler generates Bytecode that is not OS dependent. The JVM on each OS interprets the same byteCode and converts it into native machine code .which makes Java programs independent.
ex: javac MyApp.java --> MyApp.class (byteCode) program independent.

3. What is the difference between an Abstract class and an Interface?
-> An Abstract class is class that cannot be instantiated or create obj of it , and can only be inherited.
	can have Abstract and non-abstract methods
	can have constructor.
	no body to abstract methods.
-> An Interface is blueprint of class that contains only abstract methods and constants.
	Methods are public abstract by default (Java 8+ supports default & static methods).
	variables are always public static final (Constants).
	No Constructor (coz cannot be instantiated)
	Supports multiple inheritance ( class can implement multiple interfaces).
ex: Abstract Class Example -
abstract class Payment {
		void generateReceipt(){
		Syso("Receipt generated");
		}
		abstract void makePayment(); }
Here:

generateReceipt() is a common,non-abstract method

makePayment() must be implemented by child classes	

Interface Example: 
interface UPI {
    void payThroughUPI();
}

Use Case:
 class GooglePay extends Payment implements UPI {

    @Override
    void makePayment() {
        System.out.println("Payment via Bank Server");
    }

    @Override
    public void payThroughUPI() {
        System.out.println("UPI Payment");
    }
}
ðŸ‘‰ Payment (abstract class) gives common functionality
ðŸ‘‰ UPI (interface) gives capability behavior
ðŸ‘‰ GooglePay can use both

4. What is the diff between final, finally and finalize?
-> Final is used to make variable,class or method constant and cannot change later.
variable - value cannot be changed
method - cannot be overridden
class - cannot be inherited
Example : final int x = 10;  // cannot change value x = 20 â†’ error

final void display() {}  // cannot override

final class Vehicle {}   // cannot extend

->Finally is used in try-catch blocks to execute a block of code either exception is thrown or not . eg: closing db connections, closing files, freeing up threads.
example : try {
    int a = 10 / 0;
} catch (Exception e) {
    System.out.println("Exception");
} finally {
    System.out.println("Close DB connection");
}

->finalize is a prtotected method that is called by the Garbage collector for code cealnup when an object is no longer in use.
 example : @Override
protected void finalize() {
    System.out.println("Object is getting garbage collected");
}

5. what is the difference betn stack and head memory?
-> stack memory is used for storing local variables, refrences and function called
ex: void test() {
    int a = 10;      // stored in stack
    Employee e = new Employee();  // e is reference stored in stack
}

-> HEap memory is used for soring objects and instance variables.
ex: Employee e = new Employee();
e (reference) â†’ stack
actual new Employee() object â†’ heap

| Feature       | Stack                         | Heap                        |
| ------------- | ----------------------------- | --------------------------- |
| Stores        | Local variables, references   | Objects, instance variables |
| Speed         | Fast                          | Slower                      |
| Thread-safety | Each thread has its own stack | Shared across threads       |
| Managed by    | Java automatically            | Garbage Collector           |
| Errors        | StackOverflowError            | OutOfMemoryError            |

6. what is diff betn method overloading and method overriding?
-> Method Overloading means method having same names but different parameters in same class.
ex: 
class Calculator {

    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}
Here, add() is overloaded 3 times.
-> Method Overriding means there we have childParent relationship where child class can override properties or functions of there parent class by extend it and provides its own implemention.
Ex :
class Bank {
    double getRate() {
        return 5.0;
    }
}

class SBI extends Bank {
    @Override
    double getRate() {
        return 6.5;
    }
}
SBI overrides getRate().
Overriding = Child changes parent's rule

ðŸ‘‰ Example:
Father says: â€œWake up at 6 AM.â€
You say: â€œNo, I will wake up at 7 AM.â€

You override the rule â†’ Overriding.

7. What is diff betn a private and protected modifier?
-> Private modifier allow members accessible only within same class.
	Used for encapsulation and hiding sensitive data.
	Private methods cannot be overridden.
EX: 
	class A {
    private int data = 10;
    private void show() {
        System.out.println("Private Method");
    }
}
data and show() cannot be accessed from outside class A.

-> Protected modifier allow members accessible within the same class and its subclasses even in diff pkg.
EX :
class A {
    protected int value = 20;
    protected void display() {
        System.out.println("Protected Method");
    }
}

class B extends A {
    void test() {
        System.out.println(value); // allowed
        display();                 // allowed
    }
}

8. What is constructor overloading in java?
-> Constructor Overloading means creating multiple constructors in the same class with the same name but different parameters.
ex:
class Employee {

    int id;
    String name;
    String dept;

    // 1. No-arg constructor
    Employee() {
        this.id = 0;
        this.name = "Unknown";
        this.dept = "General";
    }

    // 2. Constructor with 1 parameter
    Employee(int id) {
        this.id = id;
    }

    // 3. Constructor with 2 parameters
    Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // 4. Constructor with 3 parameters
    Employee(int id, String name, String dept) {
        this.id = id;
        this.name = name;
        this.dept = dept;
    }
}
Here, the class Employee has four constructors, each providing a different way to initialize an object.